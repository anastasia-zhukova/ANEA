["Quelltext, auch Quellcode (englisch source code) oder unscharf Programmcode genannt, ist in der Informatik der f\u00fcr Menschen lesbare, in einer Programmiersprache geschriebene Text eines Computerprogrammes. Abstrakt betrachtet kann der Quelltext f\u00fcr ein Programm auch als Software-Dokument bezeichnet werden, welches das Programm formal so exakt und vollst\u00e4ndig beschreibt, dass dieses aus ihm vollst\u00e4ndig automatisch von einem Computer in Maschinensprache \u00fcbersetzt werden kann.\nQuelltext kann auch (teilweise oder komplett) nicht-textueller Form sein, zum Beispiel als grafische Verkn\u00fcpfung von logischen Funktionsbl\u00f6cken (beispielsweise in Simulink oder als UML-Diagramm). Der Quelltext eines Programms kann mehrteilig sein, zum Beispiel auf mehrere Dateien (evtl. unterschiedlicher Formate) aufgeteilt sein oder teilweise grafisch, teilweise textuell vorliegen (z. B. UML, angereichert mit Methodenimplementierungen in der verwendeten Programmiersprache).\n\n\n== Anwendung ==\n\n\n=== Erstellung ===\nQuelltext wird meist manuell mit Hilfe einer integrierten Entwicklungsumgebung oder eines Texteditors erstellt. Es gibt aber auch Codegeneratoren, die den Code aus strukturierten Entwurfsdokumenten, z. B. Struktogrammen oder UML-Entw\u00fcrfen, automatisch generieren. Eine weitere Erstellungsm\u00f6glichkeit sind Entwicklungswerkzeuge, die aus Entw\u00fcrfen Code und umgekehrt auch aus Code wieder Entw\u00fcrfe erzeugen k\u00f6nnen. Dabei werden manuelle \u00c4nderungen am Code nachtr\u00e4glich wieder in den Entwurf \u00fcbernommen. Auf diese Weise ist ein \u201eRound-Trip-Engineering\u201c m\u00f6glich, bei dem an jeder Stelle manuelle Ver\u00e4nderungen in den gesamten Entwicklungsprozess eingebracht werden k\u00f6nnen.\nZum Erstellen des Quelltextes ist meist ein einfacher Texteditor ausreichend. Mithilfe sprachspezifischer Editoren k\u00f6nnen gewisse Arbeitsschritte vereinfacht werden: Durch Syntaxhervorhebung werden Teile des Quelltextes entsprechend ihrer Funktionalit\u00e4t farblich hervorgehoben, was die Lesbarkeit verbessert. Ebenfalls zur Verbesserung der Lesbarkeit halten sich Programmierer meist an eine bestimmte Quelltextformatierung (z. B. Einr\u00fcckung von Unterabschnitten, Gro\u00df-/Kleinschreibung \u2026). In manchen Sprachen ist eine bestimmte Quelltextformatierung vorgegeben (z. B. Fortran-77, Python), manche integrierte Entwicklungsumgebung kann den Quelltext automatisch formatieren (sog. Beautifier).\nBei gr\u00f6\u00dferen Programmen, die aus vielen einzelnen Quelldateien bestehen, werden mitunter Informationen verwaltet, welche die Abh\u00e4ngigkeiten der Quelltextdateien untereinander beschreiben. Dies erlaubt beim Kompilieren mittels eines einzigen Aufrufes, alle Arbeitsschritte zur Erstellung des fertigen Programms auszuf\u00fchren und nur jene Bestandteile erneut zu \u00fcbersetzen, welche zwischenzeitlich ge\u00e4ndert wurden oder von ge\u00e4nderten Komponenten abh\u00e4ngen. Beispiel hierf\u00fcr sind Makefiles.\nZur besseren Dokumentation der \u00c4nderungen oder der gezielten Synchronisierung von mehreren gleichzeitig arbeitenden Programmierern wird der Quelltext h\u00e4ufig mit einer Software-Versionsverwaltung gespeichert, wodurch \u00c4nderungen sp\u00e4ter einsehbar sind und erforderlichenfalls r\u00fcckg\u00e4ngig gemacht werden k\u00f6nnen.\n\n\n=== \u00dcbersetzung und Ausf\u00fchrung ===\n\nBevor das Programm, das der Programmierer schreibt, von einem Computer ausgef\u00fchrt werden kann, muss es in Maschinensprache, also in eine vom Computer verst\u00e4ndliche Folge von Bits, umgesetzt werden. Dies kann entweder vorab durch einen Compiler oder \u2013 zur Laufzeit \u2013 durch einen Interpreter oder JIT-Compiler geschehen. Bei einigen Programmiersprachen wird auch eine Kombination aus beiden Varianten gew\u00e4hlt, wobei zuerst der Quelltext der jeweiligen Sprache \u2013 meist vom Programmierer veranlasst \u2013 in einen abstrakten Zwischencode \u00fcbersetzt wird, welcher dann zur Laufzeit von einer Laufzeitumgebung durch einen Interpreter oder JIT-Compiler in den Maschinencode \u00fcberf\u00fchrt wird. Dieses Prinzip hat den Vorteil, dass ein und derselbe Zwischencode auf sehr vielen verschiedenen Plattformen ausf\u00fchrbar ist und somit nicht f\u00fcr jedes auf dem Markt \u00fcbliche System eine eigene Version der Software erscheinen muss. Typische Beispiele f\u00fcr einen solchen Zwischencode sind der Java-Bytecode sowie die Common Intermediate Language. Mittels eines Debuggers kann die Funktionsweise des Programmes zur Laufzeit verfolgt werden.\nKommen bei der Programmierung Precompiler zum Einsatz, so kann der vom Programmierer erzeugte origin\u00e4re Quelltext u. a. Ausdr\u00fccke/Anweisungen enthalten, die die eigentliche Programmiersprache nicht \u201aversteht\u2018. Ein Beispiel daf\u00fcr sind SQL-Anweisungen. Solche Anweisungen werden vom Precompiler in Befehle der Programmiersprache \u00fcbersetzt; in den dabei oft nur tempor\u00e4r erzeugten Quelltextdaten werden die Originalanweisungen meist als Kommentare eingef\u00fcgt, um sichtbar zu bleiben. \u00c4hnlich wird auch beim Einsatz von Makroprozessoren verfahren: Diese generieren aus den als Makro formulierten Anweisungen Befehle der jeweiligen Programmiersprache.\nDie bei der Kompilierung erzeugten Maschinenbefehle (bei h\u00f6heren Programmiersprachen meist mehrere je Quellcodeanweisung) repr\u00e4sentieren in der Regel die programmierte Funktion selbst (bei einfachen Befehlen wie z. B. Addieren von Variableninhalten); dazu geh\u00f6ren auch Aufrufe von Betriebssystemfunktionen. Alternativ kann der Compiler eine der programmierten Anweisung entsprechende Routine, z. B. aus einer Programmbibliothek, im Zielcode direkt einf\u00fcgen \u2013 oder nur einen Aufrufbefehl f\u00fcr eine solche Routine (z. B. f\u00fcr einen Datenbankaufruf oder f\u00fcr komplexe Algorithmen). So aufgerufene Routinen f\u00fchren im Quelltext codierte Anweisungen als Unterprogramm und somit \u201agekapselt\u2018 aus.\n\n\n== Lizenzierung ==\n\nSoftware und der dazugeh\u00f6rige Quelltext unterliegen dem Urheberrecht. Sie k\u00f6nnen in zwei Kategorien unterteilt werden: Propriet\u00e4re Software und quelloffene-Software.\nQuelloffene Programme, also solche, die unter einer \u201eOpen-Source\u201c-Lizenz stehen, werden in der Regel direkt mit ihrem Quelltext ausgeliefert, dessen \u00c4nderung und Weitergabe durch die Lizenz gestattet ist. Dies erm\u00f6glicht deren Studium, Pr\u00fcfung und Anpassung f\u00fcr spezifische Bed\u00fcrfnisse. Verfechter des Open-Source-Prinzips sind der Meinung, dass dies zudem die Qualit\u00e4t verbessere, da Fachleute die Fehler besser lokalisieren k\u00f6nnten und sie entweder direkt beheben oder den urspr\u00fcnglichen Programmierern qualitativ bessere Fehlermeldungen liefern k\u00f6nnten. Die M\u00f6glichkeit, Open-Source-Software anhand ihres Quelltextes zu \u00fcberpr\u00fcfen, erh\u00f6he das Vertrauen des Anwenders in ihre Korrektheit und Funktionalit\u00e4t im Sinne des Anwenders. Freie Software ist in diesem Sinne mit Open-Source-Software identisch.\nPropriet\u00e4re Software wird in der Regel ohne Quelltext (Closed Source) oder nur unter besonders restriktiven Lizenzen ausgeliefert. Dem Schutz des Abnehmers/Anwenders dienen dann manchmal Vereinbarungen zur Quelltexthinterlegung (Source Code Escrow Agreements). Bei individuell beauftragter Erstellung von Individualsoftware durch Dritte wird in der Regel die \u00dcbergabe des Quelltexts ebenfalls vereinbart. Bei Software, die ein Anwender, zum Beispiel ein Unternehmen, f\u00fcr eigene Zwecke erstellt, sind Lizenzvereinbarungen \u00fcberfl\u00fcssig.\n\n\n== Andere Bedeutungen ==\nIm weiteren Sinne versteht man unter Quelltext auch die menschenlesbare Beschreibung eines gerenderten Mediums.\n\nDer Quelltext von Web-Seiten ist in der Regel in HTML geschrieben.\nUnter dem Quelltext von Wikipedia-Artikeln ist der Text zu verstehen, den die Autoren der Artikel eingeben. Hier ist, wie bei vielen dynamischen Webseiten, der HTML-Code das Ergebnis einer Transformation des Wiki-Codes nach HTML und CSS. Somit ist bei dynamischen Webseiten mit Quelltext h\u00e4ufig nicht das generierte HTML gemeint, sondern die Informationsquelle, aus der die Webseite generiert wird.\nAuch PostScript und andere Vektorformate sind ungerendert \u201eQuelltext\u201c.\nVHDL beschreibt elektronische Schaltungen, die in einem Simulator Datenverarbeitung betreiben k\u00f6nnen.\n\n\n== Siehe auch ==\nProgrammierstil\nEinr\u00fcckungsstil\nObfuscator (Quelltextverschleierung)\nAuszeichnungssprache - beschreibt die Darstellung, Gliederung und Formatierung ... von Texten\n\n\n== Weblinks ==\n\n\n== Einzelnachweise ==", "Ein Computerprogramm oder kurz Programm ist eine den Regeln einer bestimmten Programmiersprache gen\u00fcgende Folge von Anweisungen (bestehend aus Deklarationen und Instruktionen), um bestimmte Funktionen bzw. Aufgaben oder Probleme mithilfe eines Computers zu bearbeiten oder zu l\u00f6sen.\n\n\n== \u00dcberblick ==\n\nEin Computerprogramm geh\u00f6rt zur Software eines Computers. Es liegt meist auf einem Datentr\u00e4ger als ausf\u00fchrbare Programmdatei, h\u00e4ufig im sogenannten Maschinencode vor, die zur Ausf\u00fchrung in den Arbeitsspeicher des Rechners geladen wird. Das Programm wird als Abfolge von Maschinen-, d. h. Prozessorbefehlen von dem oder den Prozessoren des Computers verarbeitet und damit ausgef\u00fchrt. Unter Computerprogramm wird auch der Quelltext des Programms verstanden, aus dem im Verlauf der Softwareentwicklung der ausf\u00fchrbare Code entsteht.\nEine Programmdatei, die aus Maschinencode besteht, enth\u00e4lt Befehle aus dem Sprachschatz des Prozessors, d. h. Befehle, die f\u00fcr den Prozessor \u201everst\u00e4ndlich\u201c und damit ausf\u00fchrbar sind. Die Erstellung eines solchen Programms bezeichnet man allgemein als Programmierung oder auch als Implementierung. In den Anf\u00e4ngen der Programmierung wurde \u2013 bis zur Entwicklung von Programmiersprachen \u2013 ausschlie\u00dflich in Maschinencode programmiert. Der Programm- bzw. Quelltext, den der Programmierer in einer Programmiersprache abgefasst hat, besteht aus einer Abfolge von (zumeist der englischen Sprache entnommenen) Anweisungen, die f\u00fcr den Programmierer im Allgemeinen verst\u00e4ndlicher sind (z. B. ADD, SUB, AND, OR) als der Maschinencode. Sp\u00e4ter erg\u00e4nzten Schleifen, Abstraktion und modularer Aufbau die h\u00f6heren Programmiersprachen.\nDateien, in denen der Programmcode gespeichert ist, sind meist durch eine Dateiendung gekennzeichnet. Quelltextdateien weisen damit auf die verwendete Hochsprache hin (<programm>.c: ein in C formuliertes Programm). Sie kann im Allgemeinen mit einem einfachen Texteditor bearbeitet werden. Eine Datei, die dagegen Maschinencode enth\u00e4lt, besitzt keine oder eine betriebssystemspezifische Endung, die lediglich auf ihre Ausf\u00fchrbarkeit hinweist (<programm>.exe bei MS-DOS und Windows; <programm> bei unixoiden Systemen). Sie kann oft als Kommando in einem Terminal (Eingabeaufforderung) aufgerufen werden. Siehe auch Programmbibliothek.\nDamit ein in einer Hochsprache geschriebenes Programm auf einem Prozessor ausgef\u00fchrt werden kann, muss es in Maschinencode \u00fcbersetzt werden. Eine Anweisung einer h\u00f6heren Programmiersprache wird im Allgemeinen in mehrere Maschinenbefehle \u00fcbersetzt. Den \u00dcbersetzungsvorgang nennt man Kompilierung. Um aus dem Quelltext den Maschinencode zu generieren, wird ein Assembler, Compiler oder Interpreter ben\u00f6tigt. Dieser \u00fcbersetzt die Anweisungen der Programmiersprache, die f\u00fcr menschliche Benutzer verst\u00e4ndlich und bearbeitbar sein sollen, in die semantisch entsprechenden Befehle der Maschinensprache des verwendeten Computers.\nDie Anweisungen, die (als Teil von Programmen) einen konkreten L\u00f6sungsweg repr\u00e4sentieren, werden als Algorithmus bezeichnet; Beispiel: Berechnen der Mehrwertsteuer.\nIm Sprachgebrauch wird Computerprogramm meist zu Programm verk\u00fcrzt oder der Begriff Software verwendet. Allerdings ist Computerprogramm kein Synonym zu Software, da mit Software die komplette, f\u00fcr den Benutzer fertige Anwendung gemeint ist. Diese umfasst zus\u00e4tzliche Ressourcen wie Betriebssystem, Datenbanken, Grafik- und Audiodateien, Schriftarten oder Hilfetexte.\nEin gr\u00f6\u00dferes Computerprogramm besteht meist aus mehreren Modulen \u2013 die entweder zum Programm selbst geh\u00f6ren oder die als Bausteine (Unterprogramme) aus bereits bestehenden Programmbibliotheken bei der Ausf\u00fchrung des Programms benutzt werden. Im umgekehrten Fall k\u00f6nnen Computerprogramme Teil eines \u00fcbergeordneten, ein gr\u00f6\u00dferes Aufgabengebiet abdeckenden Anwendungssystems sein; Beispiel: Gehaltsabrechnung, Finanzbuchhaltung, Meldewesen.\nDie Entwicklung von Computerprogrammen ist das Gebiet der Softwaretechnik. Je nach Komplexit\u00e4t der zu entwickelnden Computerprogramme geschieht dies im Rahmen von Projekten. Die Aktivit\u00e4ten der Beteiligten werden dabei meist unter Anwendung von Vorgehensmodellen, speziellen Methoden und Werkzeugen zur Softwareentwicklung ausgef\u00fchrt.\n\n\n== Klassifizierungsm\u00f6glichkeiten ==\nNeben den f\u00fcr Software im Allgemeinen geltenden Unterscheidungsmerkmalen lassen sich Computerprogramme (als Untervariante von Software) nach den folgenden, beispielhaft genannten Kriterien unterscheiden:\n\nQuellprogramme (in einer bestimmten Programmiersprache) oder Maschinenprogramme (ausf\u00fchrbar unter bestimmten Betriebssystemen) oder Programme in einem Zwischencode\nHauptprogramme (aufgerufen \u00fcber Betriebssystem-Kommandos) oder Unterprogramme (aufgerufen durch andere Programme). Sonderformen treten auf, wenn Programme z. B. \u00fcber technische Steuerungskomponenten aufgerufen werden, z. B. \u00fcber serviceorientierte Architekturen, automatisiertes Workflow-Management.\nStapelprogramme (verarbeiten 'Stapel' von Daten) oder Dialogprogramme (stehen in Interaktion mit Benutzern)\nNach dem Ort der Speicherung und Programmausf\u00fchrung unterschieden k\u00f6nnen Programme lokal (auf einem Arbeitsplatzrechner) gespeichert und ausgef\u00fchrt werden oder auf einem Server installiert sein und trotzdem lokal (nach dem Laden \u00fcber eine Online-Verbindung) ausgef\u00fchrt werden oder nur auf dem Server gespeichert und dort auch ausgef\u00fchrt werden. Bei verteilten Anwendungen werden Programmteile auf unterschiedlichen Rechnern ausgef\u00fchrt, z. B. die Gesch\u00e4ftslogik und Datenhaltung im Server, Funktionen der Benutzeroberfl\u00e4che am lokalen Rechner; im rein technischen Sinn stehen hierbei verschiedene Programme miteinander in Verbindung.\n\n\n== Geschichte ==\n\n\n=== Das erste Computerprogramm von Ada Lovelace ===\nAls weltweit erstes Computerprogramm gilt eine Vorschrift f\u00fcr die Berechnung von Bernoulli-Zahlen, die Ada Lovelace in den Jahren 1842/1843 f\u00fcr die mechanische Analytical Engine von Charles Babbage erstellte. Das Programm konnte ihrerzeit nur von Hand ausgef\u00fchrt werden, da es im 19. Jahrhundert noch keine funktionsf\u00e4hige Maschine gab, die dazu in der Lage war.\n\n\n=== Erste Programme auf Lochstreifen ===\nIn den Jahren 1936 bis 1941 entwarf Konrad Zuse die Rechner Z1 und Z3, die lange Befehlsfolgen auf einem Lochstreifen verarbeiteten, die ersten Computerprogramme, die auf realen Maschinen ausgef\u00fchrt werden konnten. Die Rechner beherrschten die vier Grundrechenarten und Quadratwurzelberechnungen auf bin\u00e4ren Gleitkommazahlen, der Lochstreifen enthielt jeweils eine Rechenoperation und eine Speicheradresse.\nAuf Zuse geht auch die erste h\u00f6here Programmiersprache Plankalk\u00fcl zur\u00fcck. Damit lassen sich Probleme maschinenunabh\u00e4ngig formulieren und sp\u00e4ter in eine maschinenlesbare Form \u00fcberf\u00fchren.\n\n\n=== Programme im Arbeitsspeicher ===\nDer EDVAC-Rechner, der auf einem Entwurf von John von Neumann aus dem Jahre 1945 basiert, hatte einen Quecksilber-Verz\u00f6gerungsspeicher f\u00fcr 1024 Fest- oder Gleitkommazahlen mit jeweils 44 Bit. Jede Speicherzelle konnte statt einer Zahl auch einen Befehl aufnehmen. Bei diesem Rechnerkonzept war es m\u00f6glich, die Befehle eines Computerprogramms vor der Ausf\u00fchrung zuerst in den Arbeitsspeicher zu \u00fcbertragen. Das ist heute noch \u00fcblich. EDVAC wurde jedoch erst im Jahr 1951 teilweise fertiggestellt. Der Demonstrationsrechner Manchester SSE und der auf dem EDVAC aufbauende EDSAC-Rechner hatten schon vorher Programme aus dem Arbeitsspeicher ausgef\u00fchrt.\n\n\n=== H\u00f6here Programmiersprachen und Compiler ===\nEnde der 1950er-Jahre wurden Computer so leistungsf\u00e4hig, dass spezielle Programme, Compiler genannt, Quelltexte in h\u00f6heren Programmiersprachen automatisch in Maschinenbefehle, also ausf\u00fchrbare Programme, \u00fcbersetzen konnten. Ausf\u00fchrbare Programme k\u00f6nnen dann, wie beim EDVAC, in den Speicher geladen und abgearbeitet werden.\nMit Fortran, COBOL, ALGOL und LISP entstanden in den sp\u00e4ten 1950er-Jahren die ersten standardisierten h\u00f6heren Programmiersprachen. Programme in diesen Sprachen laufen, durch einen entsprechenden Compiler \u00fcbersetzt, auf unterschiedlichen Rechnern. Sie k\u00f6nnen teilweise auch noch auf modernen Computern eingesetzt werden.\n\n\n== Vom Algorithmus zum Programm ==\n\n\n=== Berechnung des gr\u00f6\u00dften gemeinsamen Teilers ===\nEs soll ein Programm zur Bestimmung des gr\u00f6\u00dften gemeinsamen Teilers (ggT) zweier Zahlen erstellt werden. Zun\u00e4chst muss ein geeigneter Algorithmus gefunden werden.\nDer Euklidische Algorithmus, der bereits um 300 v. Chr. beschrieben wurde, ermittelt den gr\u00f6\u00dften gemeinsamen Teiler (ggT) zweier nat\u00fcrlicher Zahlen a und b:\n\nSei a die gr\u00f6\u00dfere der beiden Zahlen a und b.Wenn a kleiner als b ist, dann vertausche die Zahlen.\nSetze a auf den Wert a - b.\nWenn a und b ungleich sind, dann fahre mit Schritt 1 fort.Wenn a und b gleich sind, dann ist der Algorithmus beendet.Diese Zahl ist der gr\u00f6\u00dfte gemeinsame Teiler.\n\n\n=== Verwendung einer Programmiersprache ===\nSobald eine formale Beschreibung eines Algorithmus, also eine genau definierte Verarbeitungsvorschrift, vorliegt, kann der Algorithmus umgesetzt (implementiert) werden. Dazu wird eine geeignete Programmiersprache ausgew\u00e4hlt.\nZur Umsetzung wird heute meist eine h\u00f6here Programmiersprache verwendet, die von einem Computer eventuell nicht direkt ausgef\u00fchrt werden kann, sondern zuerst kompiliert oder interpretiert werden muss.\nIn Sprachen wie Pascal dienen Variablen, Ausdr\u00fccke, Vergleiche, Zuweisungen und Kontrollstrukturen zur Umsetzung des ggT-Algorithmus:\n\n\n=== Ber\u00fccksichtigung aller Sonderf\u00e4lle ===\nBei der Umsetzung wird mit der Pr\u00fcfung von Schritt 3 begonnen. Der urspr\u00fcngliche Algorithmus ber\u00fccksichtigt nicht den Fall, dass a und b bereits zu Beginn gleich sein k\u00f6nnen. W\u00e4re es die Aufgabe, den gr\u00f6\u00dften Teiler von 103 und 103 zu finden, w\u00fcrde ein Mensch sofort das Ergebnis 103 nennen, er w\u00fcrde den Algorithmus gar nicht bem\u00fchen. Der originale Algorithmus w\u00fcrde aber null ergeben. Die Umsetzung auf einem Rechner muss auch alle Sonderf\u00e4lle ber\u00fccksichtigen. Durch das Vorziehen von Schritt 3 wird der Sonderfall hier korrekt behandelt.\n\n\n=== Elementare Schritte ===\nPascal und andere Programmiersprachen besitzen keine Operation zum Vertauschen von Zahlen. Dies muss daher in elementarere Schritte umgesetzt werden. Die zus\u00e4tzliche Variable temp, eine sogenannte Hilfsvariable, erlaubt die Vertauschung mit Hilfe von drei Zuweisungen:\n\nAuch dies ist ein kleiner Algorithmus.\n\n\n=== Ein vollst\u00e4ndiges Programm ===\nDamit daraus ein korrektes Programm wird, muss der Algorithmus noch um Ein- bzw. Ausgabeanweisungen, oft jedoch auch um Variablen und eine Programmstruktur erg\u00e4nzt werden. Diese sind nicht Teil des eigentlichen Algorithmus:\n\n\n=== \u00dcbersetzung und Ausf\u00fchrung ===\nEin solches Programm wird unter Verwendung eines Texteditors erstellt und als Quellcode in einer Datei oder Programmbibliothek (f\u00fcr Quellcode) gespeichert. Anschlie\u00dfend kann der Quellcode zu einer festen Ablaufanweisung f\u00fcr den Computer '\u00fcbersetzt\u2019 werden. Hierzu ist ein Compiler erforderlich, der den Code aus der jeweiligen Programmiersprache in die Maschinensprache \u00fcbersetzt und als Ergebnis ein ausf\u00fchrbares Programm erstellt, welches als Datei oder in einer Programmbibliothek (f\u00fcr ausf\u00fchrbare Programme) abgelegt wird. Dieses Programm kann dann \u00fcber ein Betriebssystem zur Ausf\u00fchrung gestartet werden, und zwar beliebig oft (ohne neue \u00dcbersetzung).\nEinige Programmiersprachen verwenden keinen Compiler, sondern einen Interpreter, der Programme erst zur Laufzeit in Maschinensprache \u00fcbersetzt.\nEine weitere M\u00f6glichkeit besteht in der Verwendung von Zwischencode (Bytecode), der vom Compiler an Stelle des Maschinencodes generiert wird. Ein Beispiel daf\u00fcr ist Java: Der Java-Compiler erzeugt Bytecode, welcher dann auf der sogenannten virtuellen Maschine ausgef\u00fchrt wird. Die virtuelle Maschine interpretiert oder \u00fcbersetzt dann den Bytecode f\u00fcr das darunterliegende Betriebssystem.\nEbenso muss in manchen Rechnerumgebungen, in der Regel bei Gro\u00dfrechnern, der vom Compiler erstellte Maschinencode noch mit einem Systemprogramm ('Linkage Editor' o. \u00e4.) nachbearbeitet werden, wobei ggf. weitere Unterprogramme und Systemroutinen 'eingebunden' werden k\u00f6nnen. Erst so ist das entstandene Programm ausf\u00fchrbar.\nMittels spezieller Programme, sogenannter Decompiler, ist es in begrenztem Ma\u00dfe m\u00f6glich, aus dem Maschinencode wieder einen in Hochsprache lesbaren Quelltext zu erzeugen.\n\n\n=== Lebensphasen ===\nProgramme haben mindestens zwei klar getrennte Lebensphasen: Der Zeitraum bis zum Zeitpunkt der Kompilierung (inklusive) wird Compilezeit genannt, welche im Gegensatz zur Laufzeit steht. In der Compilezeit-Phase hat das Programm statische Eigenschaften, gegeben nur durch den festen Quellcode. Nach der Kompilierung und mit der Ausf\u00fchrung besitzt das bin\u00e4re Programm dynamische Eigenschaften und Verhalten in zus\u00e4tzlicher Abh\u00e4ngigkeit der jeweiligen Laufzeitumgebung (variierende Hardware, User-Interaktion etc.).\nIn detaillierterem Sinn lassen sich die Lebensphasen von Programmen auch als Software-Lebenszyklus verstehen. Demnach geh\u00f6ren zur inhaltlich pr\u00e4zisen Festlegung des Programm-Inhalts die Projektphasen Problemstellung, Analyse und Entwurf, anschlie\u00dfend folgt die technische Implementierung, in der das Programm in Form von Quelltext entsteht. Danach befindet es sich in der Phase Einf\u00fchrung. Nach diesen Entstehungsphasen von Programmen folgt deren produktive Nutzung, bei Bedarf werden Anpassungen und Erweiterungen (Wartungs-/Pflegephase) vorgenommen.\nAus betriebswirtschaftlicher Sicht lassen sich auch Computerprogramme nach dem allgemeinen Produktlebenszyklus klassifizieren.\n\n\n== Urheberschutz ==\nEin Computerprogramm wird urheberrechtlich gesch\u00fctzt, wenn es individuelles Ergebnis einer eigenen geistigen Sch\u00f6pfung ihres Urhebers ist (\u00a7 69a Abs. 3 UrhG). Mit Umsetzung der Urheberrechtsrichtlinie aus dem Jahre 2001 wurde die Schutzschwelle f\u00fcr Computerprogramme in den EG-Mitgliedsstaaten harmonisiert. Es gen\u00fcgt ein Minimum an Individualit\u00e4t f\u00fcr den Schutz (Kleine M\u00fcnze). Es wird vermutet, dass sich die Individualit\u00e4t des Urhebers im Programm niedergeschlagen hat, wenn Spielraum dazu bestand. Geistiger Gehalt wird vermutet, wenn das Programm von einem menschlichen Urheber geschaffen wurde.\n\nEntwicklung\nIn der Bundesrepublik erfolgte die gesetzliche Anerkennung des Urheberrechtsschutzes 1985; die Rechtsprechung hielt ihn schon vorher f\u00fcr m\u00f6glich.1991 folgte die Richtlinie 91/250/EWG \u00fcber den Rechtsschutz von Computerprogrammen, 1993 gesetzliche Regelungen in \u00d6sterreich und der Schweiz sowie 1996 in Liechtenstein.In der DDR hatte die Rechtsprechung 1979 die urheberrechtliche Schutzf\u00e4higkeit verneint, jedoch konnte in Wirtschaftsvertr\u00e4gen \u00fcber wissenschaftlich-technische Leistungen die Vergabe von Software durch andere Partner als die erarbeitende Wirtschaftseinheit ausgeschlossen werden.\n\n\n== Siehe auch ==\nAnwendungssoftware\nDienstprogramm\n\n\n== Literatur ==\nJohn von Neumann: First Draft of a Report on the EDVAC. (PDF; 0,4 MB) 1945\nMart\u00edn Abadi, Takayasu It\u014d: Theoretical Aspects of Computer Software. 1997\nMasami Hagiya, John C. Mitchell: Theoretical Aspects of Computer Software. 1994\n\n\n== Weblinks ==\n\n\n== Einzelnachweise ==", "Die Plattformunabh\u00e4ngigkeit \u2013 genauer als plattform\u00fcbergreifend und allgemeiner portabel \u2013 wird in der Informationstechnik die Eigenschaft genannt, dass ein Programm auf verschiedenen Plattformen ausgef\u00fchrt werden kann. Aus dem Englischen entlehnt wird diese Eigenschaft auch als Cross-Plattform bezeichnet.\n\n\n== Einschr\u00e4nkungen ==\nEin Programm ben\u00f6tigt in der Regel immer eine sogenannte Laufzeitumgebung, in der es ausgef\u00fchrt (oder gestartet) werden und \u00fcber den gesamten Ausf\u00fchrungszeitraum hinweg stabil lauff\u00e4hig sein kann. Mit der Eigenschaft plattformunabh\u00e4ngig oder, etwas genauer, plattform\u00fcbergreifend werden Programme n\u00e4her beschrieben, die auf verschiedenen Plattformen \u2013 also Rechnersystemen mit Unterschieden in Architektur, Prozessor, \u00dcbersetzer, Betriebssystem (in diesem Fall auch betriebssystem\u00fcbergreifend genannt) und weiteren Dienstprogrammen, die zur \u00dcbersetzung oder Ausf\u00fchrung notwendig sind \u2013 lauff\u00e4hig sind. Der Grad der Plattformunabh\u00e4ngigkeit wird auch als Portabilit\u00e4t bezeichnet (aus englischen portability). Darunter wird nicht nur die bestehende Plattformunabh\u00e4ngigkeit, sondern auch der eingesch\u00e4tzte Arbeitsaufwand verstanden, der ben\u00f6tigt w\u00fcrde, um ein Programm in ein plattform\u00fcbergreifendes umzuwandeln. Dieser Vorgang wird auch Portierung oder Migration genannt.\n\n\n== Formen ==\nEs gibt verschiedene Formen von Plattformunabh\u00e4ngigkeit:\n\nWebanwendungen, welche vom Browser ausgef\u00fchrt werden.\nHierbei ist das Betriebssystem egal, es muss nur \u00fcber einen bestimmte Voraussetzungen erf\u00fcllenden Webbrowser verf\u00fcgen.\nHybrid-Apps\nAnwendungen, die unabh\u00e4ngig von der Plattform auf unterschiedlichen Betriebssystemen und unterschiedlichen mobilen Endger\u00e4t ausgef\u00fchrt werden k\u00f6nnen.\nMulti-Channel-Apps\nAnwendungen, die unabh\u00e4ngig von Endger\u00e4t und Betriebssystem ausgef\u00fchrt werden k\u00f6nnen. Diese Ger\u00e4te k\u00f6nnen sowohl mobil als auch, im Unterschied zu den Hybrid-Apps, station\u00e4r sein.\nIn Zwischencode vorliegende Software\nProgramme, die entweder in Form von Bytecode, wie haupts\u00e4chlich Java-Programme, oder eines portablen, interpretierbaren Quellcodes (Python, Perl, PHP und andere) vorliegen.\nFat Binaries und Universal Binaries\nProgrammpakete, die mehrere lauff\u00e4hige Versionen enthalten. Das Betriebssystem startet ohne Zutun des Anwenders die passende Version. Beispiele f\u00fcr \u201efat binaries\u201c sind das OpenStep-Programmformat und die \u201efat binaries\u201c unter Mac OS, die sowohl auf Motorola-680x0-basierten Apple-Rechnern als auch auf PowerPC-Macs ausf\u00fchrbar sind. Universal Binaries unter macOS laufen sowohl auf PowerPC als auch auf x86-32-Bit oder x86-64-Bit. Voraussetzung daf\u00fcr, dass eine \u201efat binary\u201c \u00fcberhaupt erstellt werden kann, ist die Portabilit\u00e4t des Quellcodes, insbesondere bez\u00fcglich der Byte-Reihenfolge (endianness) und der L\u00e4nge einer Zeigervariable.\nQuellcode-Portabilit\u00e4t\nDiese Form der Plattformunabh\u00e4ngigkeit ist h\u00e4ufig bei C-Programmen f\u00fcr Unix anzutreffen: Der Quellcode enth\u00e4lt Anweisungen, die es erlauben, die Betriebssystemunterschiede auszugleichen. Es existieren reichlich Hilfsmittel zu diesem Zweck, wie zum Beispiel GNU Autoconf. Eine weitere M\u00f6glichkeit ist die Verwendung systemunabh\u00e4ngiger Bibliotheken, wie Qt und GTK+. Viele im Quellcode portable Programme stehen bereits in vorgefertigten Versionen plattform\u00fcbergreifend bereit.\nEingeschr\u00e4nkte Plattformunabh\u00e4ngigkeit\nist gegeben, wenn zum Beispiel das Programm nur auf einem bestimmten Prozessortyp lauff\u00e4hig ist, aber auf ansonsten verschiedenen Hardware-Architekturen. Dies ist h\u00e4ufig bei in Assemblersprachen geschriebenen Programmen der Fall, wie man sie in den fr\u00fchen Zeiten der Microcomputer unter CP/M oft antraf; heute wird Assemblersprache meist nur noch f\u00fcr besonders zeitkritische Programmstellen verwendet, und zwecks Plattformunabh\u00e4ngigkeit ist meist noch eine hochsprachliche Version der gleichen Programmfunktionen beigegeben. Auch Programme, die unabh\u00e4ngig vom CPU-Typ nur auf einer bestimmten Betriebssystem-Familie funktionieren sind eingeschr\u00e4nkt plattformunabh\u00e4ngig.Im Server-Bereich, wo schon sehr fr\u00fch mit virtuellen Maschinen und virtuellen CPUs gearbeitet wurde, sieht es beim Thema Plattformunabh\u00e4ngigkeit etwas anders aus, als man es von klassischen Unix-/Linux-Portierungen her kennt \u2013 letztere fassen zwar zunehmend im Desktop-Bereich Fu\u00df, verursachen durch die starke Ausrichtung auf x86-PCs in Sachen Plattformunabh\u00e4ngigkeit allerdings oftmals eher mehr Kopfzerbrechen als klassische Unix-Anwendungen.\nHeute wird eine relative Plattformunabh\u00e4ngigkeit am h\u00e4ufigsten durch die Verwendung von Laufzeitumgebungen von Sprachen wie Java oder .NET erzielt. Allerdings wird diese scheinbare Unabh\u00e4ngigkeit wiederum durch eine Abh\u00e4ngigkeit von der Laufzeitumgebung erkauft, die nunmehr im Kern die Plattform ist.\nAllerdings trifft der Begriff \u201ePortabilit\u00e4t\u201c in beiden F\u00e4llen nicht den Kern der Sache, da es sich von Beginn an um plattformunabh\u00e4ngige Konzepte handelte \u2013 also auch alle APIs auf jedem Zielsystem im Vorhinein so nachgebildet werden m\u00fcssen, dass die Software zwangsl\u00e4ufig lauff\u00e4hig ist. Ansonsten w\u00e4re beispielsweise eine Java VM nicht zertifizierungsf\u00e4hig.\nDie Laufzeitumgebungen selbst sind auch nicht auf jeder Plattform verf\u00fcgbar, was zum Beispiel im Fall von .NET zu Entwicklungen wie der des Mono-Projektes gef\u00fchrt hat. Portierungen sind aus lizenz- oder patentrechtlichen Gr\u00fcnden meist gar nicht m\u00f6glich, daher kann man ebenso nur von einer Form von eingeschr\u00e4nkter Plattformunabh\u00e4ngigkeit sprechen.\n\n\n== Portabilit\u00e4tsmetriken ==\nDie Portabilit\u00e4t kann zum Beispiel gesch\u00e4tzt werden \u00fcber: P = 1\u2212(\u00dc+A)/E\n\u00dc \u00dcbertragungsaufwand (insbesondere Neukompilierung)\nA Anpassungsaufwand (\u00c4nderung des Quellcodes z. B. bei Austausch von Betriebssystemschnittstellen)\nE Entwicklungsaufwand f\u00fcr NeuentwicklungDabei entspricht eine Portabilit\u00e4t von 1 der Kompatibilit\u00e4t, das Programm ist also ohne \u00c4nderung auf dem Zielsystem lauff\u00e4hig; liegt Quellcode-Portabilit\u00e4t vor, ist in der Regel ein Ergebnis von > 90 % zu erwarten; wohingegen eine Portabilit\u00e4t nahe 0 eine Neuentwicklung des Programmes nahelegt.\nPortabilit\u00e4t ist kein Ma\u00df f\u00fcr die Lauff\u00e4higkeit eines Programmes auf der Zielplattform, d. h. selbst eine Portabilit\u00e4t von 99 % bedeutet nicht unbedingt, dass das Programm nutzbar ist, es bedeutet lediglich, dass eine Portierung im Vergleich zu einer Neuentwicklung deutlich weniger Aufwand erfordert.\n\n\n== Weblinks ==\n\nPlattformunabh\u00e4ngigkeit \u2013 Seite bei e-teaching.org; Stand: 21. Februar 2011\n\n\n== Einzelnachweise ==", "Programmierung (von altgriechisch \u03c0\u03c1\u03cc\u03b3\u03c1\u03b1\u03bc\u03bc\u03b1 pr\u00f3gramma \u201e\u00f6ffentlich und schriftlich bekannt gemachte Nachricht, Befehl\u201c) bezeichnet die T\u00e4tigkeit, Computerprogramme zu erstellen. Das ist ein Teilbereich der Softwareentwicklung.Computerprogramme werden mit Hilfe einer Programmiersprache formuliert (\u201ecodiert\u201c). Der Programmierer \u201a\u00fcbersetzt\u2018 dabei die vorgegebenen Anforderungen (z. B. im Pflichtenheft) und Algorithmen in eine gew\u00fcnschte Programmiersprache. Teilweise werden dazu Codegeneratoren verwendet, die Teile des Programmcodes auf Basis von Modellen (die im Entwurf entstanden sind) automatisch erzeugen.\nBeim Programmieren sind wesentliche Aspekte zur Softwarequalit\u00e4t zu ber\u00fccksichtigen und durch die Gestaltung des Quellcodes umzusetzen. Siehe dazu als Beispiele: Programmierstil, Benutzerfreundlichkeit, Wiederverwendbarkeit/Modularit\u00e4t, Wartbarkeit.\n\u201aProgrammieren\u2018 in erweitertem Sinn umfasst neben der Codeerstellung zahlreiche weitere T\u00e4tigkeiten, zum Beispiel das Testen (Entwicklertest) des Programms oder das Erstellen der Programmierdokumentation. Abgrenzen vom Begriff des Programmierens lassen sich andere T\u00e4tigkeiten zur Softwareentwicklung wie beispielsweise zum Projektmanagement, zur Anforderungsanalyse oder zur Datenmodellierung.\nJe nach angewendetem Vorgehensmodell verlaufen die Aktivit\u00e4ten zur Programmierung in zeitlich voneinander abgegrenzten Projektphasen, parallel oder iterativ. In der Praxis geschieht das Programmieren h\u00e4ufig in Teamarbeit, mit modernen Entwicklungsmethoden (wie Agile Softwareentwicklung) und Programmierwerkzeugen.\n\u00c4hnliche Bedeutungen: Umgangssprachlich bezeichnet man gelegentlich auch das Konfigurieren von Haushalts- oder anderer elektrischer Ger\u00e4te als \u201eProgrammieren\u201c. Auch Organisationseinheiten von Unternehmen, in denen Software entwickelt wird, werden oder wurden zum Teil \u201eProgrammierung\u201c genannt.\n\n\n== Geschichte ==\n\nCharles Babbage beschrieb 1834 eine programmierbare Maschine, die Analytical Engine, welche allerdings nie gebaut wurde. Ada Lovelace \u00fcbersetzte 1843 eine urspr\u00fcnglich franz\u00f6sische Beschreibung der Analytical Engine von Federico Luigi Menabrea ins Englische und f\u00fcgte eigene Notizen hinzu. Diese Anmerkungen enthielten einen tabellarischen Plan zur Berechnung der Bernoulli-Zahlen, was als das erste Programm bezeichnet wird. 1941 realisierte Konrad Zuse mit dem Z3 die erste programmgesteuerte Rechenmaschine, von 1942 an entwickelte er mit Plankalk\u00fcl die erste h\u00f6here Programmiersprache. Die Mathematikerin Grace Hopper schuf 1949 den ersten Compiler, der Quellcode in Maschinencode \u00fcbersetzt.\n\n\n== Qualit\u00e4tskriterien ==\n\nDie Qualit\u00e4t von Software entsteht zu gro\u00dfen Teilen im Rahmen der T\u00e4tigkeiten des Programmierens, besonders die folgenden Qualit\u00e4tskriterien betreffend:\n\n\n=== Korrektheit ===\n\nEin Programm muss die im Entwurf gemachten Vorgaben korrekt umsetzen. Dazu muss es in der Regel fehlerfrei sein, wobei beim Programmieren meist zwei verschiedene Arten von Fehlern auftreten:\n\nSyntaxfehler: Fehlerhaft formulierter Quellcode \u2013 man verwendet Formulierungen oder Konstrukte, die so nicht in der verwendeten Programmiersprache vorkommen (Tippfehler, Unkenntnis, \u2026). Syntaxfehler k\u00f6nnen beim \u00dcbersetzen vom Compiler/Interpreter oder Parser erkannt werden und verhindern i. d. R. die Programmausf\u00fchrung.\nSemantische Fehler: Das Programm verh\u00e4lt sich nicht wie gew\u00fcnscht, weil m\u00f6glicherweise der Algorithmus oder seine Umsetzung fehlerhaft war. Semantische Fehler k\u00f6nnen in der Regel nicht automatisch erkannt, sondern nur durch gewissenhaftes Testen gefunden werden \u2013 beispielsweise in Form von Unittests.Der \u00dcbergang zwischen diesen beiden Fehlerarten ist flie\u00dfend. Beispielsweise wird ein Tippfehler im Code (z. B. \u201e>\u201c anstatt \u201e<\u201c in einem Vergleichsbefehl) zu einem g\u00fcltigen ausf\u00fchrbaren Programm f\u00fchren, das Resultat d\u00fcrfte jedoch falsch sein. An anderer Stelle k\u00f6nnte derselbe Fehler ein Syntaxfehler sein.\n\n\n=== Robustheit ===\nStatistisch gesehen wird die meiste Zeit f\u00fcr die Entwicklung von Quelltext ben\u00f6tigt, um auf Fehler oder au\u00dfergew\u00f6hnliche Anwendungs- oder Hardwareumgebungen zu reagieren. Ein Programmtext, der auch bei unvorhergesehenen Fehlern oder ungew\u00f6hnlichen Umgebungen sinnvoll reagiert, wird als robust bzw. portabel bezeichnet. Ge\u00fcbte Programmierer k\u00f6nnen die m\u00f6glichen Fehler und Laufzeitumgebungen gut einsch\u00e4tzen und strukturieren das Programm und seinen Quelltext dementsprechend. Der Zeitdruck bei der Entwicklung von Anwendungen stellt selbst an erfahrene Programmierer immer h\u00f6chste Anspr\u00fcche hinsichtlich dieses Kriteriums.\n\n\n=== Wartbarkeit ===\nDamit eine Software dauerhaft funktioniert, muss sie wartbar sein. Das hei\u00dft, \u00c4nderungen wie Bugfixes, Anpassungen und neue Features m\u00fcssen ohne gro\u00dfen Aufwand eingepflegt werden k\u00f6nnen. Dies erfordert vor allem, dass der Programmierer keinen zu kurzen, \u201ekryptischen\u201c Quelltext (oder Quellcode) erzeugen soll, der f\u00fcr andere Entwickler nicht oder nur mit hoher Einarbeitungszeit verst\u00e4ndlich ist.\nUm solche Probleme zu vermeiden, existieren h\u00e4ufig Namenskonventionen, in denen beispielsweise selbsterkl\u00e4rende (oder auch \u201esprechende\u201c) Bezeichner/Namen f\u00fcr Variablen etc. zur Verwendung empfohlen/vorgeschrieben werden \u2013 oder die Verwendung aussagef\u00e4higer Kommentare im Code. Auch eine sinnvolle Aufteilung des Codes in intuitiv verst\u00e4ndliche Funktionen und Klassen tr\u00e4gt zum Verst\u00e4ndnis und \u00dcbersichtlichkeit bei.\n\n\n=== Effizienz ===\nIn der Regel stehen einem Programm nur begrenzte Ressourcen (Laufzeit, Speicherverbrauch, Bandbreite) zur Verf\u00fcgung. Gute Programmierung kann dazu beitragen, unn\u00f6tigen Ressourcenverbrauch zu reduzieren. Beispielsweise erfolgt dies, indem bei Verwendung gro\u00dfer Datenmengen an mehreren Stellen im Programm nicht jeweils der gesamte Datensatz kopiert wird, sondern nur die Adresse \u00fcbertragen wird, an der die Daten gespeichert werden.\n\n\n== Effiziente Programmierung ==\nGem\u00e4\u00df Niklaus Wirth zeichnet sich gute Programmierung zum einen dadurch aus, dass die Funktionen, die die jeweils verwendete Programmierumgebung bereitstellt, m\u00f6glichst effizient genutzt werden. Insbesondere geht es darum, f\u00fcr neue Aufgabenstellungen das Rad nicht immer wieder neu zu erfinden, wenn bestimmte Funktionen schon bereitgestellt werden (zum Beispiel durch die Programmierumgebung in Form von Programmbibliotheken). Sie zeichnet sich also vor allem dadurch aus, dass ein guter \u00dcberblick \u00fcber den grunds\u00e4tzlichen Funktionsumfang und die Systematik der von der Programmierumgebung bereitgestellten Funktionen (die in die zehntausende gehen k\u00f6nnen) m\u00f6glich ist. F\u00fcr eine definierte Aufgabenstellung kann in entsprechenden Dokumentationen dann schnell eine verf\u00fcgbare Funktion ermittelt, eingesetzt und ggf. erweitert werden.\n\n\n== Arbeitsmittel ==\n\nTheoretisch reichen zum Programmieren ein einfacher Texteditor und ein Compiler/Interpreter f\u00fcr die jeweilige Programmiersprache aus. In der Praxis wird jedoch zus\u00e4tzlich auf eine Reihe von Werkzeugen zur\u00fcckgegriffen, die typische Programmierarbeiten vereinfachen sollen. Dazu geh\u00f6ren beispielsweise Texteditoren mit speziellen Features wie Syntax-Highlighting, Autovervollst\u00e4ndigen und Refactoring \u2013 wobei der \u00dcbergang zur Integrierten Entwicklungsumgebung (IDE) flie\u00dfend ist.\nDaneben existieren verschiedene Werkzeuge zur Fehlersuche, sog. Debugger, sowie Programme zur Durchf\u00fchrung statischer und dynamischer Tests. Zur Performanzanalyse kann zus\u00e4tzlich ein Profiler eingesetzt werden.\nArbeiten mehrere Entwickler an derselben Software, kommen meist Versionierungssysteme zum Einsatz, die den Code inklusive fr\u00fcherer Versionen auf einem zentralen Server speichern, auf den alle beteiligten Programmierer Zugriff haben.\n\n\n== Siehe auch ==\nProgrammierger\u00e4t\nProgrammierparadigma\n\n\n== Weblinks ==\n\nJoachim Korb: Die Geschichte der Softwareprogrammierung.\nEinf\u00fchrung ins Programmieren (f\u00fcr Neueinsteiger)\nAllgemeine Grundlagen der Programmierung (Online-Buch)\n\n\n== Einzelnachweise ==", "Ein Patch (Maskulinum, selten Neutrum; von engl. to patch = flicken, ausbessern und patch = [aufgesetzter] Flicken, Flickwerk in der Bedeutung von Reparatur bzw. Nachbesserung) ist eine Korrekturauslieferung f\u00fcr Software oder Daten aus Endanwendersicht, um Fehler zu beheben \u2013 meist um bekannt gewordene Sicherheitsl\u00fccken zu schlie\u00dfen \u2013 oder bislang nicht vorhandene Funktionen nachzur\u00fcsten. Teilweise werden auch \u00c4nderungen an einer Software ohne Wissen der K\u00e4ufer oder Nutzer installiert. Bei einigen Herstellern, wie etwa Microsoft (Windows), hei\u00dfen diese Nachbesserungen gerne Aktualisierungen und Service Pack, wenn sie aus sehr vielen zusammengefassten Patches (nach teils w\u00f6chentlichen Patch days) bestehen. Der Begriff war bereits zu einer Zeit gebr\u00e4uchlich, als Korrekturen an (minimaler) Software noch auf Lochkarten durch Stanzen beziehungsweise Zukleben einzelner L\u00f6cher bewerkstelligt werden konnten.\n\n\n== Abgrenzung ==\nEin Patch ist eine Fehlerbehebung f\u00fcr ausf\u00fchrbare Programme beziehungsweise Betriebssysteme und kann auch kleinere Funktionserweiterungen enthalten. Er wird meist zeitlich begrenzt angeboten.\n\nEin Bugfix behebt Fehler im Programm-Quellcode, die Fehlfunktionen hervorrufen k\u00f6nnen.\nEin Hotfix ist eine besonders wichtige, sehr dringende Fehlerbehebung f\u00fcr ausf\u00fchrbare Programme beziehungsweise Betriebssysteme.\nEine Aktualisierung (englisch Update) ver\u00e4ndert den bestehenden Funktionsumfang von ausf\u00fchrbaren Programmen und enth\u00e4lt oft auch Fehlerbereinigungen.\n\n\n== Ziele f\u00fcr Patches ==\n\n\n=== Patch f\u00fcr Bin\u00e4rprogramme ===\nEin Patch f\u00fcr ein Bin\u00e4rprogramm ersetzt in der Regel eine oder mehrere Dateien durch eine neue Version. Patches f\u00fcr Bin\u00e4rprogramme werden meist von Herstellern propriet\u00e4rer Software f\u00fcr ihre eigenen Programme ver\u00f6ffentlicht. Verbreitet sind Patches f\u00fcr Bin\u00e4rprogramme auch unter Softwarepiraten. Hier wird mit einem Patch meist ein Kopierschutz umgangen. Auch in der Computerspieleszene sind Patches verbreitet, um Spiele zu modifizieren.\nF\u00fcr Programme (oder seltener Betriebssysteme) werden auch Aktualisierungen per Internet angeboten, die heruntergeladen und eingespielt werden k\u00f6nnen.  \nZu Zeiten des Betriebssystems CP/M waren Bildschirm- und Druckersteuerung noch nicht Teil des Betriebssystems selbst. Die Anpassung in Form von Escape-Sequenzen oder kleinen Maschinenprogrammen musste daher im Code des Anwenderprogramms vorgenommen werden, der dazu bereits reservierte Patch-Bereiche vorsah. Beispiele daf\u00fcr sind WordStar, dBASE und SuperCalc. Das Patchen wurde meist mit Hilfe eines Debuggers vorgenommen.\n\n\n=== Patch f\u00fcr Quellcode ===\nEin Patch f\u00fcr Quellcode enth\u00e4lt nur die ge\u00e4nderten Zeilen im Programmcode. Am weitesten verbreitet sind die Formate \u201eContext-diff\u201c und \u201eUnified-diff\u201c. Diese Patches dienen dazu, die \u00c4nderungen zu dokumentieren und kommunizieren. Patches sind ein essenzieller Bestandteil der Softwareentwicklung.\nUnter Unix werden Programmcode-Patches mit dem Programm diff erzeugt. Mit dem Programm patch, urspr\u00fcnglich von Larry Wall geschrieben, kann man einen Patch automatisch einspielen.\nDie meisten verbreiteten Versionsverwaltungssysteme benutzen Patches, um \u00c4nderungen zwischen Dateiversionen festzuhalten.\n\n\n== Patch-Pakete ==\nOft fassen die Hersteller mehrere Patches zu einem \u201ePaket\u201c zusammen, welches der Administrator insgesamt installieren sollte. Diese Pakete haben je nach Hersteller unterschiedliche Bezeichnungen. Auch unterscheidet man zwischen kumulierten (oft auch als kumulativ bezeichnet) Paketen und nicht-kumulierten Paketen. Bei kumulierten Paketen muss nur das neueste installiert werden, weil es die Patches der vorherigen Pakete enth\u00e4lt. Bei nicht-kumulierten Paketen muss man alle Pakete in der richtigen Reihenfolge installieren.\nBeispiele:\n\nHewlett-Packard: Patchkits f\u00fcr Tru64 UNIX, kumuliert\nMicrosoft: Service Packs f\u00fcr Windows, kumuliert\nSAP: Support Packages f\u00fcr SAP R/3, nicht-kumuliert\nSun Microsystems: Patch Clusters f\u00fcr Solaris, kumuliert\nOracle: Patchsets, kumuliert\n\n\n== Herkunft ==\nPatches werden nicht nur durch den urspr\u00fcnglichen Softwarehersteller erstellt, sondern manchmal auch von Dritten mit unterschiedlicher Motivation.\n\n\n=== Crack ===\n\nEin Patch mit dem Zweck der Umgehung von Einschr\u00e4nkungen oder Sperren, wird als \u201eCrack\u201c bezeichnet. Dabei wird der Bin\u00e4rcode eines meist kommerziellen Programms z. B. zur Schonung der empfindlichen Original-CD derart ver\u00e4ndert, dass dieses danach ohne Kopierschutz funktioniert. Diese \u00c4nderung ist in den meisten L\u00e4ndern verboten (siehe auch: Rechtliche Lage von Software-Cracks).\n\n\n=== Community Patch ===\n\nEine Software wird durch den urspr\u00fcnglichen Hersteller und Rechthalter nicht mehr nachgebessert, gepflegt, wenn der Support beendet wurde, ein Nachfolgeprodukt vertrieben wird oder die Firma nicht mehr existiert.\nIn diesen F\u00e4llen kann es vorkommen, dass die Nutzergemeinde versucht, die Pflege der Software mit Patches aufrechtzuerhalten, wenn dies nicht aus lizenzrechtlichen Gr\u00fcnden untersagt wird.\n\n\n== Siehe auch ==\nPatchday\nMicrosoft Update Service, Update-Rollup\nHotfix\nPatch (Unix)\nKernel Live Patching\nLebensende einer Software (EOL)\n\n\n== Einzelnachweise ==", "Iteration (von lateinisch iterare ,wiederholen\u2018) beschreibt allgemein einen Prozess mehrfachen Wiederholens gleicher oder \u00e4hnlicher Handlungen zur Ann\u00e4herung an eine L\u00f6sung oder ein bestimmtes Ziel. Mit dieser Bedeutung erstmals in der Mathematik verwendet, ist der Begriff heute in verschiedenen Bereichen mit \u00e4hnlicher Bedeutung in Gebrauch. Beispielsweise in der Informatik wird nicht nur der Prozess der Wiederholung, sondern auch das Wiederholte selbst als Iteration bezeichnet. In anderen Bereichen beschr\u00e4nkt sich die Bedeutung wie im lateinischen Ausgangswort auf das Wiederholen, beispielsweise in der Linguistik.\n\n\n== Dynamische Systeme ==\nIn der Mathematik, insbesondere in der Theorie der dynamischen Systeme, bezeichnet man als Iteration die wiederholte Anwendung derselben Funktion, also die Bildung (Komposition) von\n\n  \n    \n      \n        \n          f\n          \n            n\n          \n        \n        :=\n        \n          \n            \n              \n                f\n                \u2218\n                f\n                \u2218\n                \u22ef\n                \u2218\n                f\n              \n              \u23df\n            \n          \n          \n            n\n            \n               mal\n            \n          \n        \n      \n    \n    {\\displaystyle f^{n}:=\\underbrace {f\\circ f\\circ \\dotsb \\circ f} _{n{\\text{ mal}}}}\n  f\u00fcr eine gegebene Funktion \n  \n    \n      \n        f\n        :\n        X\n        \u2192\n        X\n      \n    \n    {\\displaystyle f\\colon X\\to X}\n   auf einer Menge (einem Raum) \n  \n    \n      \n        X\n      \n    \n    {\\displaystyle X}\n  .\nDie Theorie der dynamischen Systeme befasst sich insbesondere mit dem Langzeitverhalten der Orbits \n  \n    \n      \n        \n          {\n          \n            \n              f\n              \n                n\n              \n            \n            (\n            x\n            )\n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{f^{n}(x)\\right\\}}\n   von Punkten \n  \n    \n      \n        x\n        \u2208\n        X\n      \n    \n    {\\displaystyle x\\in X}\n   unter solchen Iterationen.\n\n\n=== Beispiel ===\nMan betrachte die quadratische Funktion \n  \n    \n      \n        f\n        :\n        \n          R\n        \n        \u2192\n        \n          R\n        \n      \n    \n    {\\displaystyle f\\colon \\mathbb {R} \\to \\mathbb {R} }\n  \n\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle f(x)=x^{2}}\n  .Dann ist \n  \n    \n      \n        \n          f\n          \n            n\n          \n        \n        (\n        x\n        )\n        =\n        \n          x\n          \n            \n              2\n              \n                n\n              \n            \n          \n        \n      \n    \n    {\\displaystyle f^{n}(x)=x^{2^{n}}}\n   (nicht zu verwechseln mit \n  \n    \n      \n        (\n        f\n        (\n        x\n        )\n        \n          )\n          \n            n\n          \n        \n        =\n        \n          x\n          \n            2\n            n\n          \n        \n      \n    \n    {\\displaystyle (f(x))^{n}=x^{2n}}\n  ) und man kann das Langzeitverhalten unterschiedlicher Orbits untersuchen: f\u00fcr \n  \n    \n      \n        |\n        x\n        |\n        <\n        1\n      \n    \n    {\\displaystyle \\vert x\\vert <1}\n   konvergiert \n  \n    \n      \n        \n          f\n          \n            n\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle f^{n}(x)}\n   gegen den Fixpunkt 0, f\u00fcr \n  \n    \n      \n        x\n        >\n        1\n      \n    \n    {\\displaystyle x>1}\n   gilt \n  \n    \n      \n        \n          lim\n          \n            n\n            \u2192\n            \u221e\n          \n        \n        \n          f\n          \n            n\n          \n        \n        (\n        x\n        )\n        =\n        \u221e\n      \n    \n    {\\displaystyle \\lim _{n\\to \\infty }f^{n}(x)=\\infty }\n  , f\u00fcr \n  \n    \n      \n        x\n        =\n        1\n      \n    \n    {\\displaystyle x=1}\n   ist die Folge konstant und auch f\u00fcr \n  \n    \n      \n        x\n        =\n        \u2212\n        1\n      \n    \n    {\\displaystyle x=-1}\n   bleibt die Folge ab der ersten Iteration konstant.\n\n\n=== Andere Schreibweise ===\nWegen der genannten Verwechslungsm\u00f6glichkeit finden sich in der Literatur gelegentlich die Schreibweisen\n\nDann sind beispielsweise\n\nder Sinusfunktion.\n\n\n== Numerische Mathematik ==\n\nIn der numerischen Mathematik bezeichnet Iteration eine Methode, sich der exakten L\u00f6sung eines Rechenproblems schrittweise anzun\u00e4hern (sukzessive Approximation). Sie besteht in der wiederholten Anwendung desselben Rechenverfahrens.\nDie Ergebnisse eines Schrittes werden als Ausgangswerte des jeweils n\u00e4chsten Schrittes genommen. Die Folge der Ergebnisse muss konvergieren. Wenn die Differenz zum vorangegangenen Rechenschritt kleiner als der akzeptierte Fehler ist, dann ist das Ergebnis hinreichend genau bestimmt, und das Verfahren wird beendet. Eines der bekanntesten Beispiele ist das Newton-Verfahren. Manchmal setzt man im n\u00e4chsten Schritt Ergebnisse aus zwei oder noch mehr vorangehenden Schritten an, zum Beispiel bei der Regula falsi.\nDie Konvergenzgeschwindigkeit ist ein Ma\u00df daf\u00fcr, wie brauchbar die Iterationsmethode ist.\n\n\n=== Anwendung der Methode ===\nIteration wird in F\u00e4llen angewandt, in denen das Ergebnis sich nicht in geschlossener Form berechnen l\u00e4sst, zum Beispiel bei der Kepler-Gleichung, der Berechnung der Oberfl\u00e4chenform einer asph\u00e4rischen Linse oder der W\u00e4rmeverteilung auf einer Leiterplatte.\nLineare Gleichungssysteme lassen sich unter bestimmten Voraussetzungen iterativ l\u00f6sen.\nBei Anwendungsproblemen k\u00f6nnen die Eingabedaten fehlerbehaftet sein, dann ist die \u201eexakte L\u00f6sung\u201c des gegebenen Problems nicht notwendigerweise besser als ihre Approximation. Das Iterationsverfahren wird bevorzugt, wenn es eine gute N\u00e4herung schneller liefert, als die Berechnung der exakten L\u00f6sung braucht.\nManche Funktionen auf Taschenrechnern oder auch Fraktale werden iterativ berechnet.\n\n\n=== Beispiel: Bestimmung von Nullstellen einer stetigen Funktion ===\nApproximationen an Nullstellen einer stetigen Funktion sind, sofern \u00fcberhaupt eine existiert, iterativ oft rascher gefunden als durch andere algebraische Methoden (etwa als geschlossener Ausdruck):\n\nMan w\u00e4hlt zwei N\u00e4herungswerte \n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n        ,\n        \n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle x_{1},\\,x_{2}}\n   f\u00fcr die Nullstelle der Funktion \n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n   und zwar so, dass \n  \n    \n      \n        f\n        (\n        \n          x\n          \n            1\n          \n        \n        )\n        \u22c5\n        f\n        (\n        \n          x\n          \n            2\n          \n        \n        )\n        <\n        0\n      \n    \n    {\\displaystyle f(x_{1})\\cdot f(x_{2})<0}\n   ist.\nMan stellt die Gleichung der durch \n  \n    \n      \n        (\n        \n          x\n          \n            1\n          \n        \n        ;\n        f\n        (\n        \n          x\n          \n            1\n          \n        \n        )\n        )\n      \n    \n    {\\displaystyle (x_{1};f(x_{1}))}\n   und \n  \n    \n      \n        (\n        \n          x\n          \n            2\n          \n        \n        ;\n        f\n        (\n        \n          x\n          \n            2\n          \n        \n        )\n        )\n      \n    \n    {\\displaystyle (x_{2};f(x_{2}))}\n   gegebenen Sekante auf.\nDie Schnittstelle \n  \n    \n      \n        \n          x\n          \n            3\n          \n        \n        =\n        \n          x\n          \n            1\n          \n        \n        \u2212\n        \n          \n            \n              \n                x\n                \n                  2\n                \n              \n              \u2212\n              \n                x\n                \n                  1\n                \n              \n            \n            \n              f\n              (\n              \n                x\n                \n                  2\n                \n              \n              )\n              \u2212\n              f\n              (\n              \n                x\n                \n                  1\n                \n              \n              )\n            \n          \n        \n        \u22c5\n        f\n        (\n        \n          x\n          \n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle x_{3}=x_{1}-{\\frac {x_{2}-x_{1}}{f(x_{2})-f(x_{1})}}\\cdot f(x_{1})}\n   der Sekante mit der x-Achse ist dann ein \u201ebesserer\u201c N\u00e4herungswert f\u00fcr die gesuchte Nullstelle von \n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  .\nMan wiederholt die beiden vorgenannten Schritte so lange, bis die Nullstelle mit gew\u00fcnschter Genauigkeit gefunden ist (Regula falsi).\n\n\n== Informatik ==\nNeben der mathematischen iterativen Probleml\u00f6sung wird in der Informatik auch von Iteration gesprochen, wenn\n\nein Zugriff auf Daten einer Datenstruktur Schritt um Schritt (gleichartig wiederholt) erfolgt, beispielsweise mittels einer FOREACH-Schleife.Ein spezieller Zeiger auf die Einzelobjekte nennt sich Iterator, wenn er (meist automatisch) nach jedem Zugriff auf das n\u00e4chste Datum/Objekt der Datenstruktur weiterschaltet.\nein Anweisungsblock (der sogenannte \u201eSchleifenrumpf\u201c) \u2013 durch Schleifenkontrollanweisungen gesteuert \u2013 wiederholt ausgef\u00fchrt wird; jede Ausf\u00fchrung ist eine Iteration der Schleife. Diese Art der Programmierung wird als iterative Programmierung bezeichnet.Sie steht im Gegensatz vor allem zur rekursiven Programmierung, bei der der Anweisungsblock in eine Prozedur gesteckt wird und seine Wiederholungen durch rekursive (Selbst-)Aufrufe formuliert werden.\n\n\n== Linguistik ==\nSprachwissenschaftlich bezeichnet iterativ die Aktionsart eines Verbs, das ein aus mehrfach wiederholten gleichartigen Vorg\u00e4ngen bestehendes Geschehen ausdr\u00fcckt, z. B. von flattern, krabbeln oder sticheln. Solche Wiederholungsverben werden auch Iterativa genannt.\nBei einer Wortbildung wird von Iteration gesprochen, wenn gleiche oder \u00e4hnliche Wortteile zwei- oder mehrfach wiederholt werden, so beispielsweise in Ururgro\u00dfmutter (siehe auch Reduplikation bzw. Triplikation).\n\n\n== Softwaretechnik ==\nIn der Softwaretechnik bezeichnet eine Iteration einen einzelnen Entwicklungszyklus, je nach Vorgehensmodell beginnend mit Planung, Analyse oder Entwurf, endend mit Implementierung, Test oder Wartung. Eine besondere Rolle spielen Iterationen beim Extreme Programming und beim Rational Unified Process. Bei Scrum (Agiles Projektmanagement) kommt oft ein iterativer Prozess f\u00fcr die Entwicklung von Software zum Einsatz. Man spricht hier von Feedback-Schleifen in allen Phasen der Planung, Durchf\u00fchrung, \u00dcberpr\u00fcfung und Anpassung.\n\n\n== Geschichtswissenschaft ==\nIn der Geschichtswissenschaft bezeichnet Iteration die wiederholte Aus\u00fcbung desselben Amtes in der \u00c4mterlaufbahn der r\u00f6mischen Republik. Nach dem Mos maiorum war die Iteration verp\u00f6nt. Beim Konsulat kam die mehrfache, in Ausnahmef\u00e4llen auch unmittelbar aufeinander folgende Bekleidung des Amtes allerdings schon seit der fr\u00fchen Republik vor; seit der Verfassungsreform des Diktators Sulla aus dem Jahr 82 v. Chr. war die wiederholte Bekleidung des Konsulats erst nach zehn Jahren erlaubt. Das Iterationsverbot war neben dem Kollegialit\u00e4ts- und dem Annuit\u00e4tsprinzip das wichtigste Mittel, eine gef\u00e4hrliche Machtf\u00fclle von Amtstr\u00e4gern zu verh\u00fcten.\nInsbesondere in der Krise der Republik kam die Iteration wiederholt vor: Bekannteste Beispiele sind Gaius Sempronius Gracchus, der sich in drei Jahren hintereinander zum Volkstribunen w\u00e4hlen lassen wollte, Gaius Marius, der das Konsulat in f\u00fcnf aufeinanderfolgenden Jahren (104 bis 100 v. Chr.) und insgesamt sieben Mal aus\u00fcbte, sowie Gaius Iulius Caesar, der das Konsulat in den Jahren 59, 48, 46, 45 und 44 v. Chr. bekleidete. In der Kaiserzeit ab Augustus war die Iteration des Konsulats Zeichen f\u00fcr eine herausgehobene soziopolitische Stellung. Unmittelbar aufeinanderfolgende Konsulate gab es nur bei Angeh\u00f6rigen des Kaiserhauses.\n\n\n== Philosophie ==\nJacques Derrida f\u00fchrte die Iteration in die Sprache der Philosophie ein. \u201eIteration\u201c bezeichnet hier die Wiederholung eines Begriffs im philosophischen und gesellschaftlichen Diskurs. Laut Derrida ver\u00e4ndert sich mit jeder Wiederholung (Iteration) eines Begriffs seine Bedeutung, so dass niemals dieselbe Bedeutung reproduziert wird wie beim vorausgehenden Gebrauch des Begriffs. Jede Iteration hat vielmehr eine Variation der Bedeutung zur Folge, die dem urspr\u00fcnglichen Begriff etwas hinzuf\u00fcgt und ihn bereichert. Eine urspr\u00fcngliche Definition von Begriffen, auf die man ihre Bedeutung zur\u00fcckf\u00fchren k\u00f6nnte, kann es demnach nicht geben.\n\n\n== Bau\u00f6konomie ==\nIn der Bau\u00f6konomie ist ein iterativer Prozess das schrittweise Ann\u00e4hern von urspr\u00fcnglichen Bauzielen an die machbare Umsetzung.\n\n\n== Konstruktionslehre ==\nIn der Konstruktionslehre spricht man von iterativem Vorgehen, teilweise auch von iterativem Suchen, wenn zur L\u00f6sungsfindung so vorgegangen wird, dass ausgehend von einer Eingebung des Konstrukteurs die L\u00f6sung schrittweise verbessert wird.\n\n\n== Management ==\nIm Management ist Iteration eine Vorgehensweise, um mit den Ungewissheiten und \u00dcberraschungen in komplexen Situationen umzugehen. Bei Ver\u00e4nderungen ist der Verlauf von Projekten oder die Wirkung von Handlungen nicht immer prognostizierbar. Jedes Ver\u00e4nderungsmanagement als \u201egro\u00dfen Plan\u201c mit unverr\u00fcckbaren Zielen aufzufassen, f\u00fchrt in den meisten F\u00e4llen zu \u00dcberraschungen, auf die die Planer und Umsetzer nicht vorbereitet sind. Das bedeutet nicht, Pl\u00e4ne aufzugeben, sondern sich im eigenen Vorgehen immer nur vorl\u00e4ufig sicher zu sein. Linear-kausales Projektdenken wird durch iteratives Vorgehen abgel\u00f6st: Durch Vorantasten entlang Zwecken, Interessen und Machtkonstellationen wird nach und nach Unklarheit abgebaut, Akzeptanz erreicht, Wirkung erzeugt und Routine etabliert. Die Reihenfolge der Themen und Inhalte ergibt sich erst im Laufe der Ver\u00e4nderung. \u201eAn iterative process of initial interpretation and design, implementation and improvisation, learning from change-effort, and then sharing that learning systemwide, leading to ongoing re-interpretation and redesign of the change as needed.\u201c (Anthony F. Buono / Kenneth W. Kerber: Building Organizational Change Capacity).\n\n\n== Weblinks ==\n\n\n== Einzelnachweise =="]